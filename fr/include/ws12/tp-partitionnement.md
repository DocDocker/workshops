## TP sur le partitionnement

<div class="slide-content">

  * Transformation d'une table référencée en table partitionnée
  * Fonctions d'information sur le partitionnement
  * Nouvelle commande `\dP` pour les partitions

</div>

<div class="notes">

### Clés étrangères vers une tables partitionnée

Créer les deux tables `job` et `job_detail` avec une contrainte de clé étrangère.

```sql
CREATE TABLE job (
   id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
   job_start TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
   job_end TIMESTAMP WITH TIME ZONE,
   job_name VARCHAR(50) NOT NULL
);
CREATE INDEX ON job(job_start);

CREATE TABLE job_detail (
   jobid INT REFERENCES job(id) ON DELETE CASCADE NOT NULL,
   log_date TIMESTAMP WITH TIME ZONE NOT NULL,
   log_message TEXT NOT NULL
);

-- Quelques données dans les tables
INSERT INTO job (job_end, job_name) VALUES 
   (now() + INTERVAL '1 hour', 'Daily routine');
INSERT INTO job_detail VALUES 
   (currval('job_id_seq'), now(), 'Purge is started');
INSERT INTO job_detail VALUES 
   (currval('job_id_seq'), now() + INTERVAL '1 hour', 'Purge is completed');
```

Dans un contexte de croissance, le nombre de travaux (_jobs_) augmente considérablement
et la purge de la table devient périlleuse au long terme. La transformation de 
cette table en table partionnée se revèle nécessaire.

Créer une table `job_part` ayant la même structure que la table `job` en ajoutant
le champ `job_start` dans la contrainte de clé primaire pour satisfaire les
prérequis de la clé de partionnement.

```sql
CREATE TABLE job_part (
   id INT GENERATED BY DEFAULT AS IDENTITY,
   job_start TIMESTAMP WITH TIME ZONE DEFAULT now(),
   job_end TIMESTAMP WITH TIME ZONE,
   job_name VARCHAR(50) NOT NULL,
   PRIMARY KEY (id, job_start)
) PARTITION BY RANGE (job_start);
```

La prochaine étape consiste à rattacher la table `job` en partition fille par
défaut de la future table partitionnée. Pour cela, il peut être judicieux de 
jouer les instructions dans une seule transaction et de prêter garde au respect
de la contrainte étrangère sur la table `job_detail`.

```sql
START TRANSACTION;

-- Suppression des contraintes de clé primaire pour prévenir l'erreur suivante :
-- ERROR:  multiple primary keys for table "job" are not allowed
ALTER TABLE job_detail DROP CONSTRAINT IF EXISTS job_detail_jobid_fkey;
ALTER TABLE job DROP CONSTRAINT IF EXISTS job_pkey;

-- Suppression des index au niveau de l'ancienne table pour les redéfinir sur
-- la table partitionnée de façon globale
DROP INDEX job_job_start_idx;

-- Renommage des relations pour maintenir la logique métier
ALTER TABLE job RENAME TO job_default;
ALTER TABLE job_part RENAME TO job;
ALTER INDEX job_part_pkey RENAME TO job_pkey;

-- Ajout de la table job en tant que partition
ALTER TABLE job ATTACH PARTITION job_default DEFAULT;
CREATE INDEX ON job(job_start);

-- Récupération de la dernière valeur de la séquence de la précédente table
SELECT setval(pg_get_serial_sequence('job', 'id'),
      currval(pg_get_serial_sequence('job_default', 'id')), true);

-- Suppression de l'ancienne séquence et de sa relation avec la table job_default
ALTER TABLE job_default ALTER id DROP IDENTITY, ALTER job_start DROP DEFAULT;
ALTER SEQUENCE job_part_id_seq RENAME TO job_id_seq;

-- Réactivation des contraintes de clés étrangères
-- Puisque la colonne job_start fait à présent partie de la PRIMARY KEY, il est
-- nécessaire d'ajouter cette colonne dans la table job_detail et de l'alimenter
ALTER TABLE job_detail ADD job_start TIMESTAMP WITH TIME ZONE;
UPDATE job_detail SET job_start = j.job_start
  FROM job_detail d JOIN job j ON j.id = d.jobid; 

ALTER TABLE job_detail ADD FOREIGN KEY (jobid, job_start) 
   REFERENCES job(id, job_start) ON DELETE CASCADE;

COMMIT;
```

À partir de cette étape, la table `job` est partitionnée mais toutes les lignes
passées et à venir sont stockées dans la partition `job_default`. Il est possible
de déplacer les lignes d'une partition vers une nouvelle, bien qu'il soit recommandé
de maîtriser les requêtes en provenance des utilisateurs car une série de verrous
seront posés entre les tables.

```sql
CREATE OR REPLACE PROCEDURE add_daily_partition(timestamp with time zone)
   LANGUAGE plpgsql AS $$
   DECLARE
      daily_interval INTERVAL := INTERVAL '1 day';
      tablename   VARCHAR(50) := format('job_%s', TO_CHAR($1, 'YYYYMMDD'));
      from_expr   VARCHAR(50) := date_trunc('day', $1);
      to_expr     VARCHAR(50) := date_trunc('day', $1 + daily_interval);

   BEGIN
      EXECUTE format(
         'CREATE TABLE IF NOT EXISTS %s (LIKE job_default INCLUDING CONSTRAINTS);', 
         tablename
      );      
      EXECUTE format(
         'INSERT INTO %s SELECT * FROM job_default WHERE job_start BETWEEN ''%s'' AND ''%s'';',
         tablename, from_expr, to_expr
      );      
      EXECUTE format(
         'DELETE FROM job_default WHERE job_start BETWEEN ''%s'' AND ''%s'';',
         from_expr, to_expr
      );
      EXECUTE format(
         'ALTER TABLE job ATTACH PARTITION %s FOR VALUES FROM (''%s'') TO (''%s'');',
         tablename, from_expr, to_expr
      );
   END;
$$; 

START TRANSACTION;
LOCK TABLE job;
LOCK TABLE job_detail;

-- Retrait temporaire de la clé étrangère pour réduire les risques 
-- de suppression en cascade
ALTER TABLE job_detail DROP CONSTRAINT IF EXISTS job_detail_jobid_job_start_fkey;
CALL add_daily_partition (now());
ALTER TABLE job_detail ADD FOREIGN KEY (jobid, job_start) 
   REFERENCES job(id, job_start) ON DELETE CASCADE;

COMMIT;
```

### Fonctions d'information sur le partitionnement

`pg_partition_root` renvoie la partition mère d’une partition.

```sql
$ SELECT pg_partition_root('job_default');

 pg_partition_root 
-------------------
 job
(1 row)
```

`pg_partition_ancestors` renvoie la partition mère ainsi que la partition concernée.

```sql
$ SELECT pg_partition_ancestors('job_default');

 pg_partition_ancestors 
------------------------
 job_20200124
 job
(2 rows)
```

`pg_partition_tree` renvoie tout l’arbre de la partition sous forme de tuples.

```sql
$ SELECT * from pg_partition_tree('job');

    relid     | parentrelid | isleaf | level 
--------------+-------------+--------+-------
 job          |             | f      |     0
 job_default  | job         | t      |     1
 job_20200124 | job         | t      |     1
(3 rows)
```

###  Affichage des tables partitionnées seules

La commande psql `\dP` permet à présent d'afficher les tables partitionnées,
contrairement à la commande `\d` qui affiche toutes les relations de la base.

```sql
$ \d
                   List of relations
 Schema |     Name     |       Type        |  Owner
--------+------------+--------------------+--------------
 public | job          | partitioned table | postgres
 public | job_20200124 | table             | postgres
 public | job_default  | table             | postgres
 public | job_detail   | table             | postgres
 public | job_id_seq   | sequence          | postgres
(5 rows)

$ \dP
                  List of partitioned relations
 Schema |       Name        |  Owner   |       Type        | Table 
--------+-------------------+----------+-------------------+-------
 public | job               | postgres | partitioned table | 
 public | job_job_start_idx | postgres | partitioned index | job
 public | job_part_pkey     | postgres | partitioned index | job
(3 rows)
```

</div>

----
