## TP sur le partitionnement

<div class="slide-content">

  * Support des clés étrangères
  * Fonctions d'information sur le partitionnement
  * Nouvelle commande `\dP` pour les partitions

</div>

<div class="notes">

### Clés étrangères dans les tables partitionnées 

Nous allons mettre en place une clé étrangère dans une tables partitionnée. 
La relation sera alors créée dans chacune des partitions de celle-ci.

<!-- 
TODO: réécrire un exercice sur une clé étrangère vers une table partitionnée.
-->

<!--
```sql
CREATE TABLE lieu (id INT PRIMARY KEY, nom TEXT);
INSERT INTO lieu VALUES  (1,'Lyon'),(2,'Nantes'),(3,'Paris');

CREATE TABLE meteo (
   t_id INTEGER GENERATED BY DEFAULT AS IDENTITY,
   id_lieu INT REFERENCES lieu(id) NOT NULL,
   heure_mesure timestamp DEFAULT now(),
   temperature real NOT NULL
) PARTITION BY RANGE (id_lieu, heure_mesure);

CREATE TABLE meteo_lyon_201909 PARTITION of meteo FOR VALUES
   FROM (1, '2019-09-01 00:00:00') TO (1, '2019-10-01 00:00:00');
CREATE TABLE meteo_lyon_201910 PARTITION of meteo FOR VALUES
   FROM (1, '2019-10-01 00:00:00') TO (1, '2019-11-01 00:00:00');
CREATE TABLE meteo_nantes_201909 PARTITION of meteo FOR VALUES
   FROM (2, '2019-09-01 00:00:00') TO (2, '2019-10-01 00:00:00');
CREATE TABLE meteo_nantes_201910 PARTITION of meteo FOR VALUES
   FROM (2, '2019-10-01 00:00:00') TO (2, '2019-11-01 00:00:00');
CREATE TABLE meteo_paris_201909 PARTITION of meteo FOR VALUES
   FROM (3, '2019-09-01 00:00:00') TO (3, '2019-10-01 00:00:00');
CREATE TABLE meteo_paris_201910 PARTITION of meteo FOR VALUES
   FROM (3, '2019-10-01 00:00:00') TO (3, '2019-11-01 00:00:00');
```

Nous utilisons une fonction pour peupler cette table :

```sql
CREATE OR REPLACE FUNCTION public.peuple_meteo()
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
   lieux integer[] := '{}';
   v_lieu integer;
   v_heure timestamp;
   v_temperature real;
   v_nb_insertions integer := 50000;
   v_insertion integer;
BEGIN
   lieux[0]=1;
   lieux[1]=2;
   lieux[2]=3;
   FOR v_insertion IN 1 .. v_nb_insertions LOOP
      v_lieu=lieux[floor((random()*3))::int];
      v_heure='2019-09-01'::timestamp
                   + make_interval(days => floor((random()*60))::int,
                              secs => floor((random()*86400))::int);
      v_temperature:=round(((random()*14))::numeric+10,2);
      IF EXTRACT(MONTH FROM v_heure) = 10 THEN
          v_temperature:=v_temperature-4;
      END IF;
      IF EXTRACT(HOUR FROM v_heure) <= 9
         OR EXTRACT(HOUR FROM v_heure) >= 20 THEN
          v_temperature:=v_temperature-5;
      ELSEIF EXTRACT(HOUR FROM v_heure) >= 12
         AND EXTRACT(HOUR FROM v_heure) <= 17 THEN
          v_temperature:=v_temperature+5;
      END IF;
      INSERT INTO meteo (id_lieu,heure_mesure,temperature)
        VALUES (v_lieu,v_heure,v_temperature);
   END LOOP;    
   RETURN v_nb_insertions||' mesures de température insérées';
END;
$function$;

SELECT peuple_meteo();

              peuple_meteo              
----------------------------------------
 50000 mesures de température insérées
(1 row)
```

-->

### Fonctions d'information sur le partitionnement

`pg_partition_root` renvoie la partition mère d’une partition.

```sql
$ SELECT pg_partition_root('meteo_nantes_201910');

 pg_partition_root 
-------------------
 meteo
(1 row)
```

`pg_partition_ancestors` renvoie la partition mère ainsi que la partition concernée.

```sql
$ SELECT pg_partition_ancestors('meteo_lyon_201909');

 pg_partition_ancestors 
------------------------
 meteo_lyon_201909
 meteo
(2 rows)
```

`pg_partition_tree` renvoie tout l’arbre de la partition sous forme de tuples.

```sql
$ SELECT * from pg_partition_tree('meteo');

        relid        | parentrelid | isleaf | level 
---------------------+-------------+--------+-------
 meteo               |             | f      |     0
 meteo_lyon_201909   | meteo       | t      |     1
 meteo_lyon_201910   | meteo       | t      |     1
 meteo_nantes_201909 | meteo       | t      |     1
 meteo_nantes_201910 | meteo       | t      |     1
 meteo_paris_201909  | meteo       | t      |     1
 meteo_paris_201910  | meteo       | t      |     1
(7 rows)
```

###  Affichage des tables partitionnées seules

La commande psql `\dP` permet à préset d'afficher les tables partitionnées,
contrairement à la commande `\d` qui affiche toutes les relations de la base.

```sql
$ \d
                   Liste des relations
 Schéma |    Nom     |        Type        | Propriétaire 
--------+------------+--------------------+--------------
 public | a_table    | table              | postgres
 public | fille_1_10 | table              | postgres
 public | fille_6_10 | table              | postgres
 public | mere       | table partitionnée | postgres
(4 lignes)

$ \dP
             Liste des relations partitionnées
 Schéma | Nom  | Propriétaire |        Type        | Table 
--------+------+--------------+--------------------+-------
 public | mere | postgres     | table partitionnée | 
(1 ligne)
```

</div>

----
