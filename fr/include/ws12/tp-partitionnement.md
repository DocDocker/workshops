## TP sur le partitionnement

<div class="slide-content">

  * Transformation d'une table référencée en table partitionnée
  * Fonctions d'information sur le partitionnement
  * Nouvelle commande `\dP` pour les partitions

</div>

<div class="notes">

### Clés étrangères dans les tables partitionnées 

Créer les deux tables `job` et `job_detail` avec une contrainte de clé étrangère.

```sql
CREATE TABLE job (
   id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
   job_start TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
   job_end TIMESTAMP WITH TIME ZONE,
   job_name VARCHAR(50) NOT NULL
);
CREATE INDEX ON job(job_start);

CREATE TABLE job_detail (
   jobid INT REFERENCES job(id) ON DELETE CASCADE NOT NULL,
   log_date TIMESTAMP WITH TIME ZONE NOT NULL,
   log_message TEXT NOT NULL
);

-- Quelques données dans les tables
INSERT INTO job (job_end, job_name) VALUES 
   (now() + INTERVAL '1 hour', 'Daily routine');
INSERT INTO job_detail VALUES 
   (currval('job_id_seq'), now(), 'Purge is started');
INSERT INTO job_detail VALUES 
   (currval('job_id_seq'), now() + INTERVAL '1 hour', 'Purge is completed');
```

Dans un contexte de croissance, le nombre de travaux (_jobs_) augmente considérablement
et la purge de la table devient périllieuse au long terme. La transformation de 
cette table en table partionnée se revèle nécessaire.

Créer une table `job_part` ayant la même structure que la table `job` en ajoutant
le champ `job_start` dans la contrainte de clé primaire pour satisfaire les
prérequis de la clé de partionnement.

```sql
CREATE TABLE job_part (
   id INT GENERATED BY DEFAULT AS IDENTITY,
   job_start TIMESTAMP WITH TIME ZONE DEFAULT now(),
   job_end TIMESTAMP WITH TIME ZONE,
   job_name VARCHAR(50) NOT NULL,
   PRIMARY KEY (id, job_start)
) PARTITION BY RANGE (job_start);
```

La prochaine étape consiste à rattacher la table `job` en partition fille par
défaut de la future table partitionnée. Pour cela, il peut être judicieux de 
jouer les instructions dans une seule transaction et de prêter garde au respect
de la contrainte étrangère sur la table `job_detail`.

```sql
START TRANSACTION;

-- Suppression des contraintes de clé primaire pour prévenir l'erreur suivante :
-- ERROR:  multiple primary keys for table "job" are not allowed
ALTER TABLE job_detail DROP CONSTRAINT IF EXISTS job_detail_jobid_fkey;
ALTER TABLE job DROP CONSTRAINT IF EXISTS job_pkey;

ALTER TABLE job_part ATTACH PARTITION job DEFAULT;

-- Renommage des relations pour maintenir la logique métier
ALTER TABLE job RENAME TO job_default;
ALTER TABLE job_part RENAME TO job;

-- Récupération de la dernière valeur de la séquence de la précédente table
SELECT setval(pg_get_serial_sequence('job', 'id'),
      currval(pg_get_serial_sequence('job_default', 'id')), true);

-- Suppression de l'ancienne séquence et de sa relation avec la table job_default
ALTER TABLE job_default ALTER id DROP IDENTITY, ALTER job_start DROP DEFAULT;
ALTER SEQUENCE job_part_id_seq RENAME TO job_id_seq;

-- Réactivation des contraintes de clés étrangères
-- Puisque la colonne job_start fait à présent partie de la PRIMARY KEY, il est
-- nécessaire d'ajouter cette colonne dans la table job_detail et de l'alimenter
ALTER TABLE job_detail ADD job_start TIMESTAMP WITH TIME ZONE;
UPDATE job_detail SET job_start = j.job_start
  FROM job_detail d JOIN job j ON j.id = d.jobid; 

ALTER TABLE job_detail ADD FOREIGN KEY (jobid, job_start) 
   REFERENCES job(id, job_start) ON DELETE CASCADE;

COMMIT;
```

<!--
TODO: déplacer l'index job_start_idx de job_detail à la table mère job
-->

À partir de cette étape, la table `job` est partitionnée mais toutes les lignes
passées et à venir sont stockées dans la partition `job_default`. Il est possible
de déplacer les lignes d'une partition vers une nouvelle, bien qu'il soit recommandé
de maîtriser les requêtes en provenance des utilisateurs car une série de verrous
seront posés entre les tables.

```sql
START TRANSACTION;
LOCK TABLE job;
LOCK TABLE job_detail;

-- Retrait temporaire de la clé étrangère pour réduire les risques de suppression
-- en cascade
ALTER TABLE job_detail DROP CONSTRAINT IF EXISTS job_detail_jobid_job_start_fkey;

CREATE TABLE job_20200124 (LIKE job_default INCLUDING CONSTRAINTS);
INSERT INTO job_20200124
   SELECT * FROM job_default WHERE job_start 
   BETWEEN date_trunc('day', now()) AND date_trunc('day', now() + interval '1d');

DELETE FROM job_default WHERE job_start 
   BETWEEN date_trunc('day', now()) AND date_trunc('day', now() + interval '1d');

ALTER TABLE job ATTACH PARTITION job_20200124 FOR VALUES
   FROM (date_trunc('day', now())) TO (date_trunc('day', now() + interval '1d'));

ALTER TABLE job_detail ADD FOREIGN KEY (jobid, job_start) 
   REFERENCES job(id, job_start) ON DELETE CASCADE;

COMMIT;
```

### Fonctions d'information sur le partitionnement

`pg_partition_root` renvoie la partition mère d’une partition.

```sql
$ SELECT pg_partition_root('job_20200124');

 pg_partition_root 
-------------------
 job
(1 row)
```

`pg_partition_ancestors` renvoie la partition mère ainsi que la partition concernée.

```sql
$ SELECT pg_partition_ancestors('job_20200124');

 pg_partition_ancestors 
------------------------
 job_20200124
 job
(2 rows)
```

`pg_partition_tree` renvoie tout l’arbre de la partition sous forme de tuples.

```sql
$ SELECT * from pg_partition_tree('job');

    relid     | parentrelid | isleaf | level 
--------------+-------------+--------+-------
 job          |             | f      |     0
 job_default  | job         | t      |     1
 job_20200124 | job         | t      |     1
(3 rows)
```

###  Affichage des tables partitionnées seules

La commande psql `\dP` permet à présent d'afficher les tables partitionnées,
contrairement à la commande `\d` qui affiche toutes les relations de la base.

```sql
$ \d
                   List of relations
 Schema |     Name     |       Type        |  Owner
--------+------------+--------------------+--------------
 public | job          | partitioned table | postgres
 public | job_20200124 | table             | postgres
 public | job_default  | table             | postgres
 public | job_detail   | table             | postgres
 public | job_id_seq   | sequence          | postgres
(5 rows)

$ \dP
                  List of partitioned relations
 Schema |       Name        |  Owner   |       Type        | Table 
--------+-------------------+----------+-------------------+-------
 public | job               | postgres | partitioned table | 
 public | job_job_start_idx | postgres | partitioned index | job
 public | job_part_pkey     | postgres | partitioned index | job
(3 rows)
```

</div>

----
